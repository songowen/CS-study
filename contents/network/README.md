# Network (네트워크)

## 기본 자료 구조 [▶︎ 🗒](basic.md)

- [프로세스와 스레드](./basic.md#프로세스와-스레드)
- [동기화와 교착 상태](./basic.md#동기화와-교착-상태)
- [CPU 스케줄링](./basic.md#CPU-스케줄링)
- [가상 메모리](./basic.md#가상-메모리)
- [파일 시스템](./basic.md#파일-시스템)

---

## 질의응답

<details>
<summary>브로드캐스트가 무엇이며, 언제 사용하는지 설명해 보세요.</summary>
<p>
- 정답 : 브로드캐스트란 네트워크 내 모든 호스트에게 패킷을 전송하는 전송방식입니다. 브로드캐스트가 사용되는 대표적인 상황에는 ARP request를 보내는 상황이 있습니다.
</p>
</details>

<details>
<summary>캡슐화가 무엇인지 설명해 보세요.</summary>
<p>
- 정답 : 네트워크 송신 과정에서 네트워크 참조 모델의 상위 계층 패킷은 하위 계층의 여러 트레일러가 되어 헤더가 덧붙는 과정이 반복됩니다. 네트워크를 통한 송신과정에서 여러 프로토콜 헤더가 덧붙는 이 과정을 캡슐화라고 합니다. 이때 덧붙은 헤더는 수신자에서 역캡슐화를 거쳐 제거됩니다.
</p>
</details>

<details>
<summary>MAC 주소와 IP 주소가 각각 무엇인지, 왜 두 주소를 함께 사용하는지 설명해 보세요.</summary>
<p>
- 정답 : MAC 주소는 네트워크 인터페이스에 할당되는 물리적 주소로, 로컬 네트워크 내에서 장치를 식별하는데 사용합니다. 그리고 IP 주소는 네트워크 간 통신에서 호스트를 식별하는 논리적 주소입니다. 한 호스트가 모든 네트워크, 모든 호스트의 MAC 주소를 기억하기 어렵고, MAC 주소만으로는 네트워크 간 이동경로 파악, 즉 라우팅이 불가능하기 떄문에 IP 주소도 함께 사용하는 것입니다.
</p>
</details>

<details>
<summary>서브네팅을 하는 이유를 설명해 보세요.</summary>
<p>
- 정답 : 서브네팅은 IP주소를 토대로 네트워크를 더 작은 서브네트워크로 나누기 위해 사용합니다. 서브네팅을 통해 IP 주소와 네트워크를 효율적으로 구획하고 관리할 수 있습니다.
</p>
</details>

<details>
<summary>NAT에 대해 설명해 보세요.
 </summary>
<p>
- 정답 : NAT는 IP 주소를 변환하는 기술로, 네트워크 내부에서 사용하는 사설 IP 주소와 네트워크 외부에서 사용하는 공인 IP 주소를 변환하는 데 주로 사용됩니다. 오늘날 대중적으로 활용되고 있는 NAT는 변환할 IP 주소 쌍과 포트 번호를 함께 기록하고 변환함으로써 하나의 공인 IP 주소를 여러 사설 IP 주소가 공유할 수 있도록 합니다.

</p>
</details>

<details>
<summary>TCP와 UDP의 차이가 무엇인지, 두 방식을 사용하는 경우가 어떻게 다른지 설명해 보세요.
</summary>
<p>
- 정답 :  TCP와 UDP의 차이점은 신뢰성과 연결 방식에 있습니다. TCP는 신뢰할 수 있는 연결형 프로토콜로, 데이터를 전송하기 전에 언결을 수립하고 상태 관리, 흐름 제어, 오류 제어, 혼잡 제어 등의 기능을 통해 데이터의 신뢰성과 순서를 보장합니다. 반면, UDP는 신뢰할 수 없는 비연결형 프로토콜로, 언결 수립 과정 없이 빠르게 데이터를 전송할 수 있지만, 데이터의 신뢰성과 순서를 보장하지는 않습니다. 따라서 데이터 유실 없이 안정적인 통신이 필요하다면 TCP를 사용 하고, 빠른 속도가 필요하지만 약간의 데이터 손실이 허용되는 경우에는 UDP를 사용하는 것이 적합합니다.

</p>
</details>

<details>
<summary>TCP의 연결 수립 과정을 설명해 보세요.
</summary>
<p>
- 정답 :  TCP는 쓰리 웨이 핸드세이크로 연결 수립 과정이 이루어집니다. 먼저, 클라이언트가 서버에 SYN 패킷을 보내 연결을 요청하면, 서버는 SYN 패킷을 받고 SYN-ACK 패킷으로 응답하여 연결 요청을 승인합니다. 다시 서버의 응답을 받은 클라이언트가 ACK 패킷을 성공적으로 전송하면 클라이언트와 서버 간 연결이 수립됩니다.

</p>
</details>
<details>
<summary>포트 번호란 무엇이며, 왜 포트 번호가 존재해야 하는지 설명해 보세요.
</summary>
<p>
- 정답 :  포트 번호는 컴퓨터 네트워크에서 특정 프로세스를 식별하기 위해 사용하는 숫자입니다. IP 주소가 네트워크 상의 특정 장치를 식별하는 역할이라면, 포트 번호는 그 장치 내에서 실행 중인 특정 프로세스를 식별하는 역할을 합니다. 포트 번호 없이 IP 주소만으로는 패킷을 최종적으로 주고받을 프로세스를 식별할 수 없기 때문에 포트 번호를 사용합니다.

</p>
</details>
<details>
<summary>HTTP가 스테이트풀한지, 스테이트리스한지에 대해 그 이유와 함께 설명해 보세요
</summary>
<p>
- 정답 :   HTTP는 스테이트리스 프로토콜입니다. 즉, 서버가 클라이언트의 상태를 기억하시 않기 때문에 클라이언트의 모든 HTTP 요청이 독립적으로 처리되며, 각 요청은 이전 요청과 무관하게 다뤄집니다. HTTP가 스테이트리스한 이유는 서버가 클라이언트 다수의 상태를 유지하는 부담을 덜기 위함입니다. 클라이언트의 상태를 유지하려면 서버 간의 상태 정보를 공유해야 하므로 복잡하고 번거롭습니다. 또한 스테이트리스한 특성은 서버를 쉽게 추가하거나 대체할 수 있어 확장성과 견고함을 높일 수도 있습니다.

</p>
</details>

<details>
<summary>웹 브라우저 상에 'https://www.google.com'을 입력해 웹사이트가 뜨기까지의 과정을 설명해 보세요.
</summary>
<p>
- 정답 :   가장 먼서 로컬 DNS 서버에 'www.google.com'에 해당하는 IP 주소가 케시되어 있는지를 확인합니다. 만약 로컬 DNS 서버가 해당 IP 주소를 저장하고 있다면 해당 IP 주소를 응답하고, 저장하고 있지 않다면 루트 DNS 서버부터 'com' 최상위 도메인(TLD) 서버, google 도메인 서버 등 도메인 네인을 순차적으로 질의하여 IP 주소를 얻어 냅니다.
그리고 클라이언트가 IP 주소를 알게 되면 해당 IP 주소로 TCP 연결을 설정합니다. 이 과정에서 TCP의 쓰리 웨이 핸드세이크가 수행됩니다. 클라이언트가 서버에 SYN 패킷을 보내고, 서버가 SYN-ACK 패킷으로 응답하면 다시 클라이언트가 ACK 패킷을 보내 연결을 확립합니다.
TCP 연결이 설정되면 HTTP 요청을 보냅니다. HTTPS의 경우 SSL/TLS 헨드세이크가 추가로 수행되어 보안 연결을 설정합니다. 이후 클라이언트는 GET 요청을 통해 'www.google.com'의 리소스를 요청하고, 요청을 받은 서버는 필요한 데이터를 준비하여 HTTP 응답으로 보냅니다. 이 HTTP 응답에는 요청한 웹 페이지의 HTML 문서가 포함되어 있습니다.

</p>
</details>
<details>
<summary>배포된 웹사이트의 주소가 1.2.3.4'이고, 'example.com'라는 도메인 네임을 구입했다고 가정해 보겠습니다. 이때 구입한 도메인 네임 'www.example.com'을 웹사이트에 연동 하는 과정을 설명해 보세요.
</summary>
<p>
- 정답 :   도메인 네임을 제공하는 DNS 서비스 업체의 네임 서버에 접속하여 DNS 자원 레코드를 추가하거나 편집해야 합니다. 레코드 타입 A로 도메인 네임 'www.example.com'을 서버의 IP 주소 '1.2.3.4'에 대응시키면 도메인 네임 'www.example.com'을 1, 2, 3, 4'로 변환한 수 있습니다.

</p>
</details>

<details>
<summary>HTTP의 킵 얼라이브란 무엇인가요?
</summary>
<p>
- 정답 :    HTTP의 킵 얼라이브는 지속 연결, 즉 클라이언트와 서버 간의 연결을 지속적으로 유지하여 같은 연결을 통해 여러 요청과 응답을 처리하는 기능입니다. 킵 얼라이브를 사용하면 하나의 연결을 통해 여러 요청 응답을 처리할 수 있습니다.

</p>
</details>

<details>
<summary>HTTP 1.1과 HTTP 2.0의 차이점을 설명해 보세요.
</summary>
<p>
- 정답 :   HTTP 2.0은 HTTP 1.1의 데이터 송수신 방식과 성능을 개선한 버전입니다. 지속 연결을 처음 공식적으로 지원한 HTTP 1.1은 평문으로 메시지를 주고받는 반면, HTTP 2.0은 바이너리 데이터를 기반으로 송수신하고, 헤더 압축과 서버 푸시 기능을 제공하여 성능을 항상시켰습니다. 또한 HTTP 2.0은 HTTP 멀티플렉싱을 통해 여러 요청을 병렬로 처리하여 HOL 블로킹 문제를 완화했습니다.

</p>
</details>

<details>
<summary>HTTP 메서드인 GET과 POST의 차이를 예시와 함께 설명해 보세요.
</summary>
<p>
- 정답 :   서버에서 자원의 표현을 조회하는데 사용하는 GET 메서드는 웹 페이지를 요청할 때 주로 사용합니다. 요청한 자원의 URL을 통해 필요한 정보를 명시하고, 서버가 해당 자원의 내용을 응답으로 반환합니다. 반면, POST 메서드는 서버에 특정 직업을 처리하도록 요청하는 메서드입니다. POST 요청의 경우 메시지 본문이 사용되는 경우가 많지만, GET 요청의 경우에는 메시지 본문이 잘 사용되지 않습니다.

</p>
</details>

<details>
<summary>HTTP 메서드인 PUT과 PATCH의 차이를 예시와 함께 설명해 보세요.
</summary>
<p>
- 정답 :   서버의 자원을 완전히 대체하는 데 사용하는 PUT 메서드는 클라이언트가 보낸 데이터를 기반으로 서버의 기존 자원을 전체적으로 교체하는 메서드입니다. 즉, PUT 요청은 자원의 내용을 덮어쓰기하는 메서드인 반면, PATCH 메서드는 서버 자원의 일부만 수정하는 데 사용 하는 메서드로, 자원을 부분적으로 수정합니다.

</p>
</details>

<details>
<summary>리다이렉션의 정확한 의미를 설명해 보세요.
</summary>
<p>
- 정답 :    리다이렉션은 웹 서버가 클라이언트에게 요청한 자원이 다른 위치로 이동했음을 알리고, 해당 위치로 클라이언트를 자동으로 이동시키는 동작을 의미합니다. 웹 페이지나 리소스의 URL이 변경되었을 경우, 리다이렉션을 통해 클라이언트가 올바른 경로로 요청을 보낼 수 있습니다.

</p>
</details>

<details>
<summary>HTTP 요청 메시지를 보낸 클라이언트들이 이전에 접속한 URL을 알고 싶을 때는 어떻게 해야 할까요?
</summary>
<p>
- 정답 :   Referer 헤더를 확인하면 됩니다. Referer 헤더에는 클라이언트가 HTTP 요청 메시지를 보낼 때 머물렀던 URL이 명시되어 있어 이전에 접속한 URL을 확인할 수 있습니다.

</p>
</details>

<details>
<summary> HTTP 요청 메시지를 보낸 클라이언트들의 접속 정보를 알고 싶을 때는 어떻게 해야 할까요?
</summary>
<p>
- 정답 :   User-Agent 헤더를 확인하면 됩니다. User-Agent 헤더에는 클라이언트가 사용한 브라우저의 종류와 운영체제, 아키텍치 정보, 렌더링 엔진의 종류 등 프로그램 관련 정보가 명시되어 있습니다.

</p>
</details>

<details>
<summary> HTTP가 스테이트리스하다면 [오늘 하루 그만보기]와 같은 기능은 어떻게 구현할 수 있을까요?
</summary>
<p>
- 정답 :   [오늘 하루 그만보기] 기능은 쿠키를 사용해 구현할 수 있습니다. 쿠키는 클라이언트의 상태를
유지하지 않는 스테이트리스 프로토콜의 한계를 보완하는 수단입니다.

</p>
</details>

<details>
<summary> 같은 URL에 접속해도 어떤 환경에서는 영어 페이지가, 어떤 환경에서는 한국어 페이지가 응답되는 이유는 무엇인가요?
</summary>
<p>
- 정답 :   콘텐츠 협상이라는 기능 때문입니다. 콘텐츠 협상이란 같은 자원에 대한 다양한 표현 중 클라이언트가 가장 선호하는 자원의 표현을 제공하는 기능입니다. 클라이언트는 요청 메시지의 헤더를 통해 선호하는 언어를 서버에 알릴 수 있고, 서버는 이를 보고 클라이언트가 선호하는 언어로 응답할 수 있습니다.

</p>
</details>

<details>
<summary> HTTP 캐시가 오래된 경우 원본 데이터와의 차이가 발생할 수 있습니다. 이 문제를 해결하는 방법을 설명해 보세요.
</summary>
<p>
- 정답 :   캐시된 데이터와 원본 데이터가 불일치할 경우, 클라이언트는 If-Modified-Since 헤더나 Ii-None-Match 헤더를 사용해 서버에 원본 데이터의 변경 여부를 확인할 수 있습니다. 이 때 If-Modified-since 헤더는 특정 날짜 이후의 변경 여부를 확인하고, If-None-Match 헤더는 자원의 버전 식별자인 Etag 값을 사용해 변경 여부를 확인합니다. 서버는 버전 변경이 없으면 304 상태 코드로 알리고, 변경이 있으면 새로운 자원을 반환합니다.

</p>
</details>

<details>
<summary> HTTPS의 동작에 대해 HTTP와 비교하여 설명해 보세요.
</summary>
<p>
- 정답 :   HTTP와 HTTPS의 차이는 HTTPS가 TLS를 통해 보안을 추가한 프로토콜이라는 점에 있습 니다. 그렇기 때문에 HTTPS의 연결 수립 과정에는 TCP 핸드셰이크 이후 TLS 핸드셰이크 과정이 포함되어 있습니다. 이 과정에서 암호화 통신을 위한 키 교환과 인증서 검증 등이 이루어지고, HTTPS는 암호화 통신을 수행하게 됩니다.

</p>
</details>

<details>
<summary> 포워드 프록시와 리버스 프록시의 차이를 설명해 보세요.
</summary>
<p>
- 정답 :   포워드 프록시는 클라이언트와 가까운 위치에 있으며, 클라이언트의 요청을 받아 서버로 전달하는 역할을 합니다. 주로 캐시 저장, 클라이언트 암호화, 접근 제한 등을 통해 클라이언트를 대리합니다. 반면, 리버스 프록시는 오리진 서버와 가까운 위치에 있으며, 클라이언트의 요청을 받아 오리진 서버의 응답을 클라이언트에 전달하는 역할을 합니다. 주로 캐시 저장과 로드 밸런싱을 수행합니다.

</p>
</details>

<details>
<summary> 스케일 업과 스케일 아웃의 차이를 설명해 보세요.
</summary>
<p>
- 정답 :   스케일 업은 더 높은 사양의 하드웨어를 추가하는 등 더 뛰어난 성능의 자원으로 대체하여 성
능을 높이는 방법이고, 스케일 아웃은 여러 시스템을 추가하여 처리 능력을 확장하는 방법입니다.

</p>
</details>
<details>
<summary> 웹 서버와 웹 애플리케이션의 차이점이 무엇인지, 이 둘을 함께 사용하는 이유가 무엇인지 설명해 보세요.
</summary>
<p>
- 정답 :   웹 서버는 정적인 콘텐츠를 응답하고, 웹 애플리케이션 서버는 정적인 콘텐츠와 더불어 동적 인 컨텐츠도 응답할 수 있습니다. 웹 서버와 웹 애플리케이션을 함께 사용할 경우 정적인 정 보는 웹 서버가 응답하고, 동적인 정보는 웹 애플리케이션 서버가 응답함으로써 부하를 분산 할 수 있고, 여러 웹 서버 및 웹 애플리케이션을 확장하는 데에 유리합니다.

</p>
</details>
