# Network (네트워크)

## 기본 자료 구조 [▶︎ 🗒](basic.md)

- [프로세스와 스레드](./basic.md#프로세스와-스레드)
- [동기화와 교착 상태](./basic.md#동기화와-교착-상태)
- [CPU 스케줄링](./basic.md#CPU-스케줄링)
- [가상 메모리](./basic.md#가상-메모리)
- [파일 시스템](./basic.md#파일-시스템)

---

## 질의응답

<details>
<summary>브로드캐스트가 무엇이며, 언제 사용하는지 설명해 보세요.</summary>
<p>
- 정답 : 브로드캐스트란 네트워크 내 모든 호스트에게 패킷을 전송하는 전송방식입니다. 브로드캐스트가 사용되는 대표적인 상황에는 ARP request를 보내는 상황이 있습니다.
</p>
</details>

<details>
<summary>캡슐화가 무엇인지 설명해 보세요.</summary>
<p>
- 정답 : 네트워크 송신 과정에서 네트워크 참조 모델의 상위 계층 패킷은 하위 계층의 여러 트레일러가 되어 헤더가 덧붙는 과정이 반복됩니다. 네트워크를 통한 송신과정에서 여러 프로토콜 헤더가 덧붙는 이 과정을 캡슐화라고 합니다. 이때 덧붙은 헤더는 수신자에서 역캡슐화를 거쳐 제거됩니다.
</p>
</details>

<details>
<summary>MAC 주소와 IP 주소가 각각 무엇인지, 왜 두 주소를 함께 사용하는지 설명해 보세요.</summary>
<p>
- 정답 : MAC 주소는 네트워크 인터페이스에 할당되는 물리적 주소로, 로컬 네트워크 내에서 장치를 식별하는데 사용합니다. 그리고 IP 주소는 네트워크 간 통신에서 호스트를 식별하는 논리적 주소입니다. 한 호스트가 모든 네트워크, 모든 호스트의 MAC 주소를 기억하기 어렵고, MAC 주소만으로는 네트워크 간 이동경로 파악, 즉 라우팅이 불가능하기 떄문에 IP 주소도 함께 사용하는 것입니다.
</p>
</details>

<details>
<summary>서브네팅을 하는 이유를 설명해 보세요.</summary>
<p>
- 정답 : 서브네팅은 IP주소를 토대로 네트워크를 더 작은 서브네트워크로 나누기 위해 사용합니다. 서브네팅을 통해 IP 주소와 네트워크를 효율적으로 구획하고 관리할 수 있습니다.
</p>
</details>

<details>
<summary>NAT에 대해 설명해 보세요.
 </summary>
<p>
- 정답 : NAT는 IP 주소를 변환하는 기술로, 네트워크 내부에서 사용하는 사설 IP 주소와 네트워크 외부에서 사용하는 공인 IP 주소를 변환하는 데 주로 사용됩니다. 오늘날 대중적으로 활용되고 있는 NAT는 변환할 IP 주소 쌍과 포트 번호를 함께 기록하고 변환함으로써 하나의 공인 IP 주소를 여러 사설 IP 주소가 공유할 수 있도록 합니다.

</p>
</details>

<details>
<summary>TCP와 UDP의 차이가 무엇인지, 두 방식을 사용하는 경우가 어떻게 다른지 설명해 보세요.
</summary>
<p>
- 정답 :  TCP와 UDP의 차이점은 신뢰성과 연결 방식에 있습니다. TCP는 신뢰할 수 있는 연결형 프로토콜로, 데이터를 전송하기 전에 언결을 수립하고 상태 관리, 흐름 제어, 오류 제어, 혼잡 제어 등의 기능을 통해 데이터의 신뢰성과 순서를 보장합니다. 반면, UDP는 신뢰할 수 없는 비연결형 프로토콜로, 언결 수립 과정 없이 빠르게 데이터를 전송할 수 있지만, 데이터의 신뢰성과 순서를 보장하지는 않습니다. 따라서 데이터 유실 없이 안정적인 통신이 필요하다면 TCP를 사용 하고, 빠른 속도가 필요하지만 약간의 데이터 손실이 허용되는 경우에는 UDP를 사용하는 것이 적합합니다.

</p>
</details>

<details>
<summary>TCP의 연결 수립 과정을 설명해 보세요.
</summary>
<p>
- 정답 :  TCP는 쓰리 웨이 핸드세이크로 연결 수립 과정이 이루어집니다. 먼저, 클라이언트가 서버에 SYN 패킷을 보내 연결을 요칭하면, 서버는 SYN 패킷을 받고 SYN-ACK 패킷으로 응답하여 연결 요청을 승인합니다. 다시 서버의 응답을 받은 클라이언트가 ACK 패킷을 성공적으로 전송하면 클라이언트와 서버 간 연결이 수립됩니다.

</p>
</details>
<details>
<summary>포트 번호란 무엇이며, 왜 포트 번호가 존재해야 하는지 설명해 보세요.
</summary>
<p>
- 정답 :  포트 번호는 컴퓨터 네트워크에서 특정 프로세스를 식별하기 위해 사용하는 숫자입니다. IP 주소가 네트워크 상의 특정 장치를 식별하는 역할이라면, 포트 번호는 그 장치 내에서 실행 중인 특정 프로세스를 식별하는 역할을 합니다. 포트 번호 없이 IP 주소만으로는 패킷을 최종적으로 주고받을 프로세스를 식별할 수 없기 때문에 포트 번호를 사용합니다.

</p>
</details>
<details>
<summary>HTTP가 스테이트풀한지, 스테이트리스한지에 대해 그 이유와 함께 설명해 보세요
</summary>
<p>
- 정답 :   HTTP는 스테이트리스 프로토콜입니다. 즉, 서버가 클라이언트의 상태를 기억하시 않기 때문에 클라이언트의 모든 HTTP 요청이 독립적으로 처리되며, 각 요청은 이전 요청과 무관하게 다뤄집니다. HTTP가 스테이트리스한 이유는 서버가 클라이언트 다수의 상태를 유지하는 부담을 덜기 위함입니다. 클라이언트의 상태를 유지하려면 서버 간의 상태 정보를 공유해야 하므로 복잡하고 번거롭습니다. 또한 스테이트리스한 특성은 서버를 쉽게 추가하거나 대체할 수 있어 확장성과 견고함을 높일 수도 있습니다.

</p>
</details>

<details>
<summary>웹 브라우저 상에 'https://www.google.com'을 입력해 웹사이트가 뜨기까지의 과정을 설명해 보세요.
</summary>
<p>
- 정답 :   가장 먼서 로컬 DNS 서버에 'www.google.com'에 해당하는 IP 주소가 케시되어 있는지를 확인합니다. 만약 로컬 DNS 서버가 해당 IP 주소를 저장하고 있다면 해당 IP 주소를 응답하고, 저장하고 있지 않다면 루트 DNS 서버부터 'com' 최상위 도메인(TLD) 서버, google 도메인 서버 등 도메인 네인을 순차적으로 질의하여 IP 주소를 얻어 냅니다.
그리고 클라이언트가 IP 주소를 알게 되면 해당 IP 주소로 TCP 연결을 설정합니다. 이 과정에서 TCP의 쓰리 웨이 핸드세이크가 수행됩니다. 클라이언트가 서버에 SYN 패킷을 보내고, 서버가 SYN-ACK 패킷으로 응답하면 다시 클라이언트가 ACK 패킷을 보내 연결을 확립합니다.
TCP 연결이 설정되면 HTTP 요청을 보냅니다. HTTPS의 경우 SSL/TLS 헨드세이크가 추가로 수행되어 보안 연결을 설정합니다. 이후 클라이언트는 GET 요청을 통해 'www.google.com'의 리소스를 요청하고, 요청을 받은 서버는 필요한 데이터를 준비하여 HTTP 응답으로 보냅니다. 이 HTTP 응답에는 요청한 웹 페이지의 HTML 문서가 포함되어 있습니다.

</p>
</details>
<details>
<summary>배포된 웹사이트의 주소가 1.2.3.4'이고, 'example.com'라는 도메인 네임을 구입했다고 가정해 보겠습니다. 이때 구입한 도메인 네임 'www.example.com'을 웹사이트에 연동 하는 과정을 설명해 보세요.
</summary>
<p>
- 정답 :   도메인 네임을 제공하는 DNS 서비스 업체의 네임 서버에 접속하여 DNS 자원 레코드를 추가하거나 편집해야 합니다. 레코드 타입 A로 도메인 네임 'www.example.com'을 서버의 IP 주소 '1.2.3.4'에 대응시키면 도메인 네임 'www.example.com'을 1, 2, 3, 4'로 변환한 수 있습니다.

</p>
</details>

<details>
<summary>HTTP의 킵 얼라이브란 무엇인가요?
</summary>
<p>
- 정답 :    HTTP의 킵 얼라이브는 지속 연결, 즉 클라이언트와 서버 간의 연결을 지속적으로 유지하여 같은 연결을 통해 여러 요청과 응답을 처리하는 기능입니다. 킵 얼라이브를 사용하면 하나의 연결을 통해 여러 요청 응답을 처리할 수 있습니다.

</p>
</details>

<details>
<summary>HTTP 1.1과 HTTP 2.0의 차이점을 설명해 보세요.
</summary>
<p>
- 정답 :   HTTP 2.0은 HTTP 1.1의 데이터 송수신 방식과 성능을 개선한 버전입니다. 지속 연결을 처음 공식적으로 지원한 HTTP 1.1은 평문으로 메시지를 주고받는 반면, HTTP 2.0은 바이너리 데이터를 기반으로 송수신하고, 헤더 압축과 서버 푸시 기능을 제공하여 성능을 항상시켰습니다. 또한 HTTP 2.0은 HTTP 멀티플렉싱을 통해 여러 요청을 병렬로 처리하여 HOL 블로킹 문제를 완화했습니다.

</p>
</details>

<details>
<summary>HTTP 메서드인 GET과 POST의 차이를 예시와 함께 설명해 보세요.
</summary>
<p>
- 정답 :   서버에서 자원의 표현을 조회하는데 사용하는 GET 메서드는 웹 페이지를 요청할 때 주로 사용합니다. 요청한 자원의 URL을 통해 필요한 정보를 명시하고, 서버가 해당 자원의 내용을 응답으로 반환합니다. 반면, POST 메서드는 서버에 특정 직업을 처리하도록 요청하는 메서드입니다. POST 요청의 경우 메시지 본문이 사용되는 경우가 많지만, GET 요칭의 경우에는 메시지 본문이 잘 사용되지 않습니다.

</p>
</details>

<details>
<summary>HTTP 메서드인 PUT과 PATCH의 차이를 예시와 함께 설명해 보세요.
</summary>
<p>
- 정답 :   서버의 자원을 완전히 대체하는 데 사용하는 PUT 메서드는 클라이언트가 보낸 데이터를 기반으로 서버의 기존 자원을 전체적으로 교체하는 메서드입니다. 즉, PUT 요청은 자원의 내용을 덮어쓰기하는 메서드인 반면, PATCH 메서드는 서버 자원의 일부만 수정하는 데 사용 하는 메서드로, 자원을 부분적으로 수정합니다.

</p>
</details>

<details>
<summary>리다이렉션의 정확한 의미를 설명해 보세요.
</summary>
<p>
- 정답 :    리다이렉션은 웹 서버가 클라이언트에게 요칭한 자원이 다른 위치로 이동했음을 알리고, 해당 위치로 클라이언트를 자동으로 이동시키는 동작을 의미합니다. 웹 페이지나 리소스의 URL이 변경되었을 경우, 리다이렉션을 통해 클라이언트가 올바른 경로로 요청을 보낼 수 있습니다.

</p>
</details>

<details>
<summary>HTTP 요청 메시지를 보낸 클라이언트들이 이전에 접속한 URL을 알고 싶을 때는 어떻게 해야 할까요?
</summary>
<p>
- 정답 :   Referer 헤더를 확인하면 됩니다. Referer 헤더에는 클라이언트가 HTTP 요청 메시지를 보낼 때 머물렀던 URL이 명시되어 있어 이전에 접속한 URL을 확인할 수 있습니다.

</p>
</details>

<details>
<summary> HTTP 요청 메시지를 보낸 클라이언트들의 접속 정보를 알고 싶을 때는 어떻게 해야 할까요?
</summary>
<p>
- 정답 :   User-Agent 헤더를 확인하면 됩니다. User-Agent 헤더에는 클라이언트가 사용한 브라우저의 종류와 운영체제, 아키텍치 정보, 렌더링 엔진의 종류 등 프로그램 관련 정보가 명시되어 있습니다.

</p>
</details>
