# Operating System (운영체제)

## 기본 자료 구조 [▶︎ 🗒](basic.md)

- [프로세스와 스레드](./basic.md#프로세스와-스레드)
- [동기화와 교착 상태](./basic.md#동기화와-교착-상태)
- [CPU 스케줄링](./basic.md#CPU-스케줄링)
- [가상 메모리](./basic.md#가상-메모리)
- [파일 시스템](./basic.md#파일-시스템)

---

## 질의응답

<details>
<summary>운영체제의 커널이 무엇이며, 커널이 왜 존재하는지에 대해 설명해 보세요. (134p, 141p)</summary>
<p>
- 정답 : 커널은 운영체제의 핵심 부분으로, 컴퓨터 하드웨어와 응용 프로그램 간의 중재자 역할을 합니다. 커널은 프로세스와 스레드가 올바르게 실행되도록 돕고, 이들이 CPU, 메모리, 보조기억장치 등의 하드웨어를 공정하게 할당받아 실행되도록 합니다. 또 커널은 이중 모드를 운영해 사용자 응용 프로그램이 안전하고 효율적으로 시스템 자원을 사용할 수 있도록 합니다.

- 신우 : 메모리에서 운영체제가 상주해있는 부분을 커널이라고 하며, 사용자가 실행하는 응용 프로그램을 대신하여 컴퓨터의 자원 관리 및 할당, 프로세스 및 스레드를 관리하기 위해 존재합니다.
</p>
</details>

<details>
<summary>메모리 누수는 무엇이며, 어떻게 해결할 수 있는지 설명해 보세요. (145p)</summary>
<p>
- 정답 : 메모리 누수는 프로그램이 할당받은 메모리를 해제하지 않아 메모리가 지속적으로 점유되는 현상을 말합니다. 메모리 누수 문제를 해결하기 위해서는 메모리를 사용한 후 명시적으로 해제하거나 프로그래밍 언어의 가비지 컬렉션을 활용해 정리해야 합니다.

- 신우 : 프로그램이 필요하지 않은 메모리를 계속 점유하는 현상으로, 메모리의 힙 영역에서 메모리 공간을 반환하지 않을 경우 발생합니다. 이는 사용되지 않는 힙 메모리를 해제하는 가비지 컬렉션으로 정리할 수 있습니다.
</p>
</details>

<details>
<summary>지나치게 문맥 교환이 반복되면 어떤 문제가 발생할 수 있나요? (150p)</summary>
<p>
- 정답 : 빈번한 문맥 교환은 실제 작업보다 문맥 저장과 복구에 CPU 시간을 사용하게 되므로 효율성을 떨어뜨립니다. 또한 캐시 메모리의 데이터를 반복적으로 무효화하게 되므로 캐시미스율이 증가하고, 캐시 미스와 문맥 교환 오버헤드로 인한 전체 시스템의 처리 속도가 저하될 수 있습니다.

- 신우 : 지나치게 문맥 교환이 반복될 경우 캐시미스가 발생할 확률이 늘어나 비효율적이게 됩니다.
</p>
</details>

<details>
<summary>블로킹 입출력과 논블로킹 입출력의 차이점에 대해 설명해 보세요. (152p)</summary>
<p>
- 정답 : 블로킹 입출력과 논블로킹 입출력의 차이는 프로세스가 입출력 작업을 수행할 때 대기하는지 여부에 있습니다. 블로킹 입출력에서 프로세스가 입출력 작업을 시작하면 해당 작업이 완료될 때까지 대기하는 반면, 논블로킹 입출력에서는 프로세스가 입출력 작업을 시작한 후, 작업이 완료되기를 기다리지 않고 곧바로 다음 명령을 수행합니다.

- 신우 : 블로킹 입출력의 경우 시스템 콜이 발생하면 시스템 콜의 입출력 작업이 완료되기 전 까지 대기하게 되지만, 논 블로킹 입출력의 경우는 시스템 콜이 발생할 경우 해당 시스템 콜이 정상적으로 송신이 된 것을 확인한 직후 해당 입출력 작업의 실행 결과를 기다리지 않고 다음 명령을 수행합니다.
</p>
</details>

<details>
<summary>동일한 코드를 여러 프로세스로 동시에 실행하는 것과 여러 스레드로 프로세스를 실행하는 것에는 어떤 차이가 있나요? (156p) </summary>
<p>
- 정답 : 차이점은 자원 공유 여부에 있습니다. 동일한 코드를 여러 프로세스에서 동시에 실행하는 경우, 기본적으로 각 프로세스는 독립적으로 실행되며 메모리, 파일 등의 자원을 공유하지 않습니다. 반면, 여러 스레드로 프로세스를 실행하는 경우, 동일한 프로세스 내에서 실행되며 자원을 공유합니다. 따라서 스레드 간에는 통신과 협력이 쉽지만, 한 스레드의 문제가 전체 프로세스에 영향을 줄 수 있습니다. 반면, 프로세스는 스레드와 달리 서로 독립적이기 때문에 한 프로세스의 문제가 다른 프로세스에 미치는 영향이 적습니다.

- 신우 : 여러 프로세스를 동시에 실행하는 것은 멀티프로세스로, 서로의 자원을 공유하지 않는 방면, 여러 스레드로 프로세스를 실행하는 경우에는 서로 자원을 공유한다는 차이점이 있습니다.
</p>
</details>

<details>
<summary>스레드를 생성하고 실행할 때 사용하는 join에 대해 설명해 보세요. (158p)</summary>
<p>
- 정답 : join은 생성된 스레드의 실행이 완료될 때까지 기다리게 하는 메서드를 말합니다. 생성된 스레드의 실행이 종료되기도 전에 해당 스레드를 생성한 스레드가 종료되거나 다음 작업을 수행하는 것을 방지할 수 있습니다.

- 신우 : 스레드를 생성한 주체가, 생성/실행된 스레드가 종료될 때까지 대기해야 함을 의미합니다.
</p>
</details>

<details>
<summary>공유메모리 기반 IPC가 소켓 통신보다 빠른 이유를 설명해 보세요. (160p)</summary>
<p>
- 정답 : 공유 메모리는 동일한 메모리 공간에 직접 접근하여 데이터를 주고받고, 마치 자신의 메모리 공간을 읽고 쓰는 것처럼 IPC가 이루어지기 때문에 빠릅니다. 이에 반해 소켓 통신은 주고받는 데이터가 커널을 통하므로 추가적인 오버헤드가 발생할 수 있어, 공유 메모리 기반 IPC보다 다소 느릴 수 있습니다.

- 신우 : 공유 메모리 기반 IPC의 경우 프로세스들이 각자의 메모리 영역을 쓰고 읽는 것 뿐이기 때문에, 커널을 통해 데이터를 송수신하는 소켓 통신보다 빠릅니다.
</p>
</details>

<details>
<summary>소스 코드를 실행했더니 ‘Segmentation fault(core dumped)’라는 메시지와 함께 코드가 작동하지 않습니다. 어떻게 해야 할까요? (163p)</summary>
<p>
- 정답 : 생성된 코어 덤프 파일에 비정상 종료 당시의 메모리 상태나 비정상 종료 원인을 유추할 정보가 명시되어 있을 것입니다. 이 코어 덤프 파일을 분석하여 문제의 원인을 파악해야 합니다. 가령 코어 덤프 파일에 스택 트레이스가 포함되어 있을 경우, 문제가 발생한 순간 함수 호출 관계로 문제 발생 시점을 진단할 수 있습니다.

- 신우 : 코어 덤프는 프로그램이 비정상적으로 종료되는 경우 생성되는 파일입니다. 특정 시점에서 작업하던 메모리 상태가 기록되어 있으므로, 해당 파일을 가지고 디버깅을 하면 문제의 원인을 찾을 수 있습니다.
</p>
</details>

<hr>
- **현재 진도**
<hr>

<details>
<summary>다음 코드에는 문제가 있습니다. 어떤 문제가 있는지 설명해보세요. (167p)

```C++
#include <stdio.h>
#include <pthread.h>

int shared_data = 0;	// 공유 데이터

void* increment(void* arg) {
	int i;
	for (i = 0; i < 100000; i++){
		shared_data++;	// 공유 데이터 증가
	}
	return NULL;
}

void* decrement(void* arg){
	int i;
	for (i = 0; i < 100000; i++){
		shared_data--;	// 공유 데이터 감소
	}
	return NULL;
}

int main(){
	pthread_t thread1, thread2;

	pthread_create(%thread1, NULL, increment, NULL);
	pthread_create(%thread2, NULL, decrement, NULL);

	pthread_join(thread1, NULL);
	pthread_join(thread2, NULL);

	printf("Final value of shared_data: %d\n", shared_data);

	return 0
}
```
</summary>
<p>
- 정답 : 여기에 정답을 적어주세요.
</p>
</details>

<details>
<summary>위에서 제시한 코드의 문제를 해결해보세요. (170p)</summary>
<p>
- 정답 : 여기에 정답을 적어주세요.
</p>
</details>

<details>
<summary>스레드 안전하지 않은 메서드를 동기화하지 않으면 어떤 문제가 생길 수 있나요? (186p)</summary>
<p>
- 정답 : 여기에 정답을 적어주세요.
</p>
</details>

<details>
<summary>교착상태가 무엇인지, 왜 발생하는지 설명해 보세요. (189p)</summary>
<p>
- 정답 : 여기에 정답을 적어주세요.
</p>
</details>

<details>
<summary>리눅스 운영체제에서 일반적인 사용자 프로세스가 어떻게 CPU를 할당 받아 실행되는지 설명해 보세요. (202p)</summary>
<p>
- 정답 : 여기에 정답을 적어주세요.
</p>
</details>

<details>
<summary>디버깅할 때 주로 볼 수 있는 주소는 실제 물리 메모리 주소일까요? (206p)</summary>
<p>
- 정답 : 여기에 정답을 적어주세요.
</p>
</details>

<details>
<summary>메모리가 부족하면 어떤 현상이 발생할 수 있는지 설명해 보세요. (207p, 221p)</summary>
<p>
- 정답 : 여기에 정답을 적어주세요.
</p>
</details>

<details>
<summary>4GB보다 큰 크기의 프로그램을 4GB인 물리 메모리로 실행할 수 있을까요? 실행할 수 있다면 어떻게 가능할까요? (209p)</summary>
<p>
- 정답 : 여기에 정답을 적어주세요.
</p>
</details>

<details>
<summary>페이지 폴트를 처리하는 과정을 설명해보세요. (215p)</summary>
<p>
- 정답 : 여기에 정답을 적어주세요.
</p>
</details>

<details>
<summary>프로세스의 페이지 테이블이 모두 메모리에 적재될 경우에 발생할 수 있는 문제점과 해결 방안을 설명해 보세요. (217p)</summary>
<p>
- 정답 : 여기에 정답을 적어주세요.
</p>
</details>

<details>
<summary>파일 디스크립터는 무엇을 식별하는 정보인가요? (225p)</summary>
<p>
- 정답 : 여기에 정답을 적어주세요.
</p>
</details>

<details>
<summary>응용 프로그램이 새로운 파일을 만들고, “hello”라는 문자열을 입력한 뒤 저장했습니다. 이 과정에서 컴퓨터 내부(커널)에서는 어떤 일이 발생하는지 설명해 보세요. (225p)</summary>
<p>
- 정답 : 여기에 정답을 적어주세요.
</p>
</details>

<details>
<summary>공장 초기화된 보조기억장치가 있다고 가정해보세요. 이때 파일 시스템을 만들고, 텍스트 파일을 저장하기까지의 과정을 설명해 보세요. (231p)</summary>
<p>
- 정답 : 여기에 정답을 적어주세요.
</p>
</details>

<details>
<summary>- EXT4 파일 시스템에서 디렉터리 내 파일의 데이터를 찾는 과정을 설명해 보세요. (233p)</summary>
<p>
- 정답 : 여기에 정답을 적어주세요.
</p>
</details>

<details>
<summary>아이노드란 무엇이며, 아이노드에는 어떤 정보를 저장하는지 설명해 보세요 (233p)<br>
(부팅 과정을 설명해 보세요)</summary>
<p>
- 정답 : 여기에 정답을 적어주세요.
</p>
</details>

<details>
<summary>운영체제가  메모리에 적재되기 까지의 과정을 설명해 보세요. (239p)<br>
(부팅 과정을 설명해 보세요)</summary>
<p>
- 정답 : 여기에 정답을 적어주세요.
</p>
</details>

<details>
<summary>가상 머신과 컨테이너의 차이점에 대해 설명해 보세요. (241p)</summary>
<p>
- 정답 : 여기에 정답을 적어주세요.
</p>
</details>