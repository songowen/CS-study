# Computer Structure (컴퓨터 구조)

## 기본 자료 구조 [▶︎ 🗒](basic.md)

- [컴퓨터가 이해하는 정보](./basic.md#컴퓨터가-이해하는-정보)
- [CPU](./basic.md#CPU)
- [메모리](./basic.md#메모리)
- [보조 기억장치와 입출력 장치](./basic.md#보조기억장치와-입출력장치)

---

## 질의응답

<details>
<summary>RAM과 하드디스크의 차이에 대해서 설명해주세요.</summary>
<p>
- RAM이 CPU가 실행할 프로그램을 저장하는 부품이라면 하드디스크는 전원이 꺼져도 보관할 프로그램을 저장하는 부품
- 휘발성 저장장치인 RAM은 전원이 꺼지면 저장된 내용을 잃지만, 하드디스크는 비휘발성 저장장치이기 때문에 전원이 꺼져도 내용이 남아있다는 차이가 있습니다.
</p>
</details>

<details>
<summary>base64 인코딩이 무엇이며 어디에서 base64 인코딩을 사용하는지 설명해보세요.</summary>
<p>

- 문자 뿐만 아니라 아스키 코드로 표현할 수 없는 이미지 등의 이진 데이터까지 아스키 형태의 문자로 표현하기 위해 사용하는 인코딩 방식
- 주로 이메일에서 첨부파일을 전송하거나 웹에서 이미지 및 파일 데이터를 텍스트 형식으로 포함할 때 사용

창현:

- Base64 인코딩은 바이너리 데이터를 텍스트로 변환하는 인코딩 방식입니다. 변환된 데이터는 일반 텍스트 형식으로 유지되며, 이로 인해 바이너리 데이터를 안전하게 전송하거나 저장할 수 있습니다.
- 이메일에서 첨부파일을 보낼 때 사용합니다. 이메일 프로토콜(SMTP)에서는 바이너리 데이터를 직접 전송할 수 없기 때문에 첨부파일을 Base64로 인코딩하여 전송합니다.
- JWT는 Base64 인코딩을 사용하여 서버와 클라이언트 간에 데이터를 안전하게 주고받을 수 있도록 설계되었습니다.

- Base64를 사용하지 않는 경우:

일반 파일 업로드 (웹사이트): 대부분의 웹사이트에서 파일을 업로드할 때는 Base64 인코딩이 필요하지 않습니다. 브라우저에서 파일을 서버로 업로드할 때는 파일을 그대로 바이너리 형식으로 서버에 전송합니다. 이 과정에서는 **enctype="multipart/form-data"**를 사용하여 바이너리 데이터를 전송하며, Base64로 인코딩할 필요가 없습니다.

</p>
</details>

<details>
<summary>유니코드란 무엇인지 설명하세요.</summary>
<p>

- 여러 국가의 언어나 이모티콘 등을 표현할 수 있는 통일된 문자 집합
- 유니코드마다 부여되어있는 고유한 수 , 코드 포인트를 어떻게 코드로 표현하는지에 따라 다양한 인코딩 방법을 구분 할 수 있습니다.

창현:

- \*유니코드(Unicode)**는 전 세계의 모든 문자를 통일된 방식으로 표현하기 위해 개발된 **문자 인코딩 표준\*\*입니다. 각 언어의 문자, 기호, 이모지 등을 고유한 코드로 정의하여 컴퓨터에서 일관되게 처리할 수 있도록 설계되었습니다.
</p>
</details>

<details>
<summary>코딩을 하다 한글이 깨지면 어떻게 하나요?</summary>

<p>

- 한글이 깨지는 경우는 컴퓨터가 이해할 수 있는 문자의 모음, 문자집합을 인식하지 못했거나, 문자집합을 코드로 표현하는 인코딩 방법을 인식하지 못한 경우입니다
- 따라서 다른 문자 집합을 지원하는 다양한 인코딩 방법을 시도해봐야 합니다

신우 :

- 해당 코딩 환경에서 인식할 수 있는 인코딩 방법, 한글은 대표적으로 EUC-KR과 유니코드등을 확인해 봐야 합니다.
</p>
</details>

<details>
<summary>다음 소스코드의 결과는 모두 ‘0.300000000000000004’입니다. 그 이유에 대해 설명하세요.</summary>
<p>

![문제이미지](img/floating_point.png)

- **부동소수점 수의 이진 표현**:
  컴퓨터는 실수를 이진수(2진법)로 표현합니다. 하지만 `0.1`이나 `0.2` 같은 소수는 이진수로 정확하게 표현할 수 없습니다. 이러한 숫자들은 이진수로 무한하게 반복되므로, 컴퓨터는 이러한 값을 근사치로 저장하게 됩니다.
- **정밀도 한계**:
  컴퓨터가 사용하는 부동소수점 표현(일반적으로 IEEE 754 표준)은 고정된 비트 수를 사용해 소수를 표현합니다. 이로 인해, `0.1 + 0.2`의 결과도 정확히 `0.3`이 아니라 근사치가 됩니다. 이 근사값을 10진수로 변환하면 `0.30000000000000004`로 나타나게 됩니다. 이는 매우 작은 오차이지만, 부동소수점 연산에서는 이러한 오차가 발생할 수밖에 없습니다.
- **언어 간 일관성**:
  Python, Java, JavaScript 같은 언어들은 모두 IEEE 754 표준을 따르기 때문에 동일한 결과가 출력됩니다. 각 언어의 내부적인 소수점 처리 방식이 같기 때문에, 같은 수식을 계산할 때 동일한 오차가 발생합니다.

신우 :

- 실수를 다른 진수로 표현할 때, 정확하게 나누어 떨어지지 않아 무한이 반복되는 수들이 있습니다. 컴퓨터의 경우 데이터를 이진수로 저장하는데, '0.1'이나 '0.2'등은 2진수로 무한이 반복되기 때문에 저장할 수 있는 최대 자릿수에서 근사치를 저장합니다. 이 때문에 '0.1'이 컴퓨터에서는 '0.1'에 가까운 근사값이 나오게 되며 컴퓨터에서는 '0.1 + 0.2 = 0.3' 이 아닌 '0.1 + 0.2 = 0.3000000000000004' 가 나오게 됩니다.
</p>
</details>

<details>
<summary>CPU가 자발적으로 발생시키는 인터럽트와 CPU가 받아들이는 인터럽트의 차이가 무엇인지 설명해 보세요.</summary>
<p>
- **CPU가 자발적으로 발생시키는 인터럽트**는 소프트웨어 인터럽트로 주로 에러와 같은 예외의 상황에서 발생합니다.

**CPU가 받아들이는 인터럽트**는 주로 입출력 장치와 같은 하드웨어 인터럽트에서 일어납니다.

</p>
</details>

<details>
<summary>하드웨어적 스레드와 소프트웨어적 스레드의 차이에 대해 설명해 보세요.</summary>
<p>
- 하드웨어 스레드는 `하나의 코어가 동시에 처리하는 명령어의 단위`를 말합니다.

소프트웨어 스레드는 `하나의 프로그램에서 독립적으로 실행되는 단위`를 의미합니다.

하드웨어 스레드는 `병렬성`을, 소프트웨어 스레드는 `동시성`을 중심으로 작동합니다.

</p>
</details>

<details>
<summary>병렬성과 동시성, 두 개념의 차이를 예시와 함께 설명해 보세요.</summary>
<p>
- 병렬성은 작업을 실제로 같은 시간에 동시에 처리하는 성질을 의미하고 동시성은 작업을 동시에 처리하게끔 보이게하는 성질을 의미합니다. 멀티코어 CPU의 여러 코어가 같은 시각에 명령어를 동시에 처리하는 것이 병렬성의 예시이고, 1코어 1스레드 CPU가 여러 작업을 빠르게 번갈아가며 처리하는 것이 동시성의 예시입니다.
</p>
</details>

<details>
<summary>파이프라이닝이란 무엇이며, 어떻게 CPU성능을 향상시키는지 설명해 보세요.</summary>
<p>
- 명령어 병렬 처리기법은 여러 명령어를 동시에 처리해 CPU의 성능을 높이는 기법입니다.  파이프라이닝은 하나의 명령어를 처리하는 과정을 비슷한 시간 간격으로 쪼갠 뒤, 쪼개진 각각의 단계에서 동시에 실행 가능한 단계를 겹쳐서 실행해 CPU의 처리 성능을 높입니다.
</p>
</details>

<details>
<summary>동일한 소스 코드라 하더라도 애플M1 컴퓨터에서 컴파일 해 만든 실행파일을 인텔x86 컴퓨터로 옮겨 실행할 수 없는 이유를 설명해 보세요.</summary>
<p>
- 동일한 소스코드라도 각기 다른 명령어로 변환될 수 있기 때문입니다. 실행파일은 각각의 컴퓨터가 이해할 수 있는 명령어의 모음이기 때문에 CPU마다 이해하는 명령어의 집합이 다릅니다. 따라서 실행할 수 있는 실행파일도 달라집니다.
</p>
</details>

<details>
<summary>캐시 미스란 무엇이며, 캐시미스가 프로그램의 성능에 어떤 영향을 끼치는지 설명해 보세요.</summary>
<p>
- 캐시미스란 캐시에 있을 것이라고 기대했던 데이터가 캐시에 존재하지 않는 상황을 의미합니다. 캐시 미스가 발생하면 CPU가 메모리와 같이 실제로 데이터가 위치한 먼 곳까지 접근해야 합니다. 따라서 프로그램의 성능에 악영향을 끼치게 됩니다. 
</p>
</details>

<details>
<summary>다음 소스코드에 성능상의 문제가 있습니다. 어떤 문제인지 설명해 보세요.</summary>

```JAVA
public class Main {
	public static void main(String[] args){
		int[][] matix = new int[20000][20000];

		for (int i = 0; i < 20000; i++) {
			for (int j = 0; j < 20000; j++){
				matrix[j][i] = 1;
			}
		}
	}
}
```

<p>
- 배열 탐색에서 성능 문제가 발생하는 이유는 **캐시 효율성**과 관련이 있습니다. 컴퓨터 시스템에서 **캐시**는 데이터를 메모리에서 읽어오는 속도를 높이기 위해 사용되며, 이때 ****공간적 지역성** (Spatial Locality)**이 중요한 역할을 합니다.

- **공간적 지역성**이란 **메모리의 인접한 데이터들이 자주 함께 접근될 가능성**이 높다는 원칙을 말합니다. 즉, 배열의 원소들을 순차적으로 탐색하면 CPU 캐시가 한 번에 여러 개의 인접한 배열 원소를 가져오고, 이후 탐색할 때 이미 캐시된 데이터를 사용할 수 있어 성능이 향상됩니다.
- 그러나, 배열을 **비순차적으로 탐색**하면, 캐시에 미리 로드된 인접 데이터들을 활용하지 못하고, **캐시 미스(cache miss)**가 자주 발생하게 됩니다. 그 결과 메모리에서 데이터를 다시 가져와야 하는 횟수가 늘어나고, 성능이 저하됩니다.

배열을 탐색할 때는 **순차적으로 접근**하는 것이 성능을 극대화할 수 있는 방법입니다. 배열을 순차적으로 접근하면 공간적 지역성을 활용하여 CPU 캐시의 효율성을 극대화할 수 있습니다.

</p>
</details>

<details>
<summary>장치 드라이버 왜 설치해야 하나요?</summary>
<p>
- CPU가 장치컨트롤러를 작동시키기 위한 정보를 알아야 하기 때문입니다. CPU는 장치 드라이버가 설치되어 있지 않으면 해당 입출력 장치를 어떻게 작동시켜야할지, 즉 장치 컨트롤러와 어떻게 정보를 주고받아야하는지 알 수가 없습니다.
</p>
</details>

<details>
<summary>PCIe이란 무엇이며 PCIe가 연결부품의 성능과 어떤 연관이 있는지 설명해 보세요.</summary>
<p>
- PCle란 대표적인 입출력 버스의 일종으로 버전에 따라 지원되는 최대속도(대역폭)이가 다르므로 연결되는 부품의 성능에 영향을 끼칠 수 있습니다. 예를들어 PCle 3.0의 최대지원 속도는 PCle 6.0의 최대 지원 속도에 비해 느리기 때문에 같은 부품이라 하더라도 PCle 3.0에 연결할 경우 입출력 버스의 최대 지원 속도가 더 느릴수 있습니다.
</p>
</details>

<details>
<summary>GPU와 CPU를 비교하여 설명해 보세요.</summary>
<p>
- GPU는 주로 산술 연산과 같이 단순 연산을 병렬적으로 수행하기 위한 장치이고, CPU는 범용적인 연산을 수행하기 위한 장치입니다. GPU는 코어가 수백개에서 수천개까지 되기 때문에 병렬처리에 용이합니다. 하지만 CPU처럼 코어마다 복잡한 연산을 지원하지는 않습니다.
</p>
</details>

<details>
<summary>파이프라인 위협에 대해 설명해주세요(오준)</summary>
<p>
- 파이프라인 위협은 데이터 위협, 제어 위협, 구조적 위협(자원 위협)으로 나뉘어집니다. 데이터 위협은 의존성을 가진 두 명령어가 동시에 실행될 때 발생합니다, 제어 위협은 Jump나 Call, Interupt 같은 분기 명령어에 의해 프로그램 카운터가 갑작스럽게 변함으로서 발생하는 위협입니다. 마지막으로 구조적 위협은 CPU의 레지스터나 ALU에 동시에 접근하여 발생하는 위협입니다.
</p>
</details>

<details>
<summary>슈퍼 스칼라가 무엇인지 설명해주세요(창현)</summary>
<p>
- 슈퍼스칼라는 CPU 내부에 여러 개의 명령어 파이프라인을 포함하는 구조를 말합니다. 전통적인 단일 파이프라인 구조와 달리, 슈퍼스칼라 구조에서는 여러 명령어를 동시에 병렬로 실행할 수 있어 명령어 처리 효율성과 CPU 성능을 크게 향상시킵니다. 이를 통해 CPU는 클럭 사이클당 여러 개의 명령어를 처리하여, 처리량(Throughput)을 높이고 보다 빠른 성능을 발휘할 수 있습니다.
</p>
</details>

<details>
<summary>CSIC와 RISC의 특징과, 파이프라이닝에 어떤것이 더 유리한지 설명해주세요 (신우)</summary>
<p>
- 여기에 설명을 적어주세요
</p>
</details>

<details>
<summary>참조 지역성의 원리 중 시간 지역성에 대해 설명하고, 그에 대한 예시를 들어보시오 (태연) </summary>
<p>
- 참조 지역성의 원리 중 시간 지역성은 CPU가 최근에 접근했던 메모리 공간에 다시 접근하려는 경향이 있다는 것이다.
- 그에 대한 예시는 프로그래밍 언어의 변수다. 변수를 설정하게 되면, 저장된 메모리 공간에 사용할 때마다 다시 접근하게 된다.
</p>
</details>

<details>
<summary>RAID란 무엇인가요? 종류를 아는 대로 설명하세요</summary>
<p>
보조기억장치를 관리하는 방법중에 하나,RAID는 여러 개의 디스크를 하나의 논리적 디스크처럼 구성하여 성능, 용량, 안정성을 향상시키는 기술입니다.RAID 0은 데이터를 여러 디스크에 분산하여 저장하여 성능을 향상시키는 방식입니다. 단, ***디스크가 하나라도 고장나면 전체 데이터가 손실됩니다.***RAID 1은 데이터를 두개의 디스크에 완전히 복제하여 안정성을 향상시키는 방식입니다. 단, ***디스크 용량이 절반으로 줄어듭니다.***
</p>
</details>

<details>
<summary>프로그램 입출력에 대해 설명하고, 두 가지 입출력 방식에 대해 설명하시오 (태연) </summary>
<p>
- 프로그램 입출력이란, 프로그램 속 명령어로 입출력 작업을 수행하는 방법이다. 두 가지 입출력 방식으로는 고립형 입출력과 메모리 맵 입출력이 있다.
- 고립형 입출력 : 입출력 장치에 접근하는 주소와 메모리 장치에 접근하는 주소를 구분하는 방식이다. 입출력 장치에 접근하는 별도의 명령어가 필요하다.
- 메모리 맵 입출력 : 입출력 장치와 메모리에 접근하는 주소를 따로 구분하지 않는 방식이다. 메모리에 부여된 주소 일부를 사용하며, 입출력 장치에 접근하기 위한 별도의 명령어가 필요 없다.
</p>
</details>

<details>
<summary>교착 상태의 해결방법 3가지에 대해 말해보시오(태연) </summary>
<p>
- 교착 상태 예방
	- 운영체제가 애초에 교착 상태의 발생 조건에 부합하지 않도록 자원을 분배하는 방식
	예시 :  한 프로세스에 필요한 자원 몰아줌 -> 점유와 대기 조건 만족X
	예시 : 할당 가능한 모든 자원에 번호를 매기고 오름차순 할당 -> 원형 대기 조건 만족 X
- 교착 상태 회피
	- 운영체제가 교착 상태가 발생하지 않을 정도로 조금씩 자원을 할당
	예시 : 교착 상태란, 한정된 자원의 무분별한 할당으로 인해 발생하는 문제(모든 프로세스들이 한 번에 많은 자원을 요구하면 발생 위험이 증가한다)
- 교착 상태 검출 후 회복
	- 운영체제가 자원을 제약 없이 할당하다가 교착 상태가 검출되면 회복
	예시 : 자원을 할당할 때마다 주기적으로 교착 상태 발생 여부를 체크하며, 교착 상태가 검출되면 "자원 선점을 통해 회복" 시키거나 프로세스를 "강제 종료함으로써 회복" 시킴
	- 자원 선점이란, 교착 상태가 해결될 때까지 다른 프로세스로부터 강제로 자원을 빼앗아 한 프로세스에 몰아서 할당하는 것
</p>
</details>