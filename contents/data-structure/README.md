# Operating System (운영체제)

## 기본 자료 구조 [▶︎ 🗒](basic.md)

- [프로세스와 스레드](./basic.md#프로세스와-스레드)
- [동기화와 교착 상태](./basic.md#동기화와-교착-상태)
- [CPU 스케줄링](./basic.md#CPU-스케줄링)
- [가상 메모리](./basic.md#가상-메모리)
- [파일 시스템](./basic.md#파일-시스템)

---

## 질의응답

<details>
<summary>1. 다음 두 코드는 모두 정수형 리스트 ‘arr’을 인자로 전달받아 같은 작업을 수행하는 함수입니다. 두 코드 중 더 효율적이라고 판단하는 코드를 고르고 이 이유를 설명해보세요.</summary>

```python
def first(arr):
    n = len(arr)
    # 배열의 모든 요소를 순회합니다
    for i in range(n):
        # 현재 위치에서 인접한 요소들을 비교합니다
        for j in range(0, n - i - 1):
            # 만약 앞의 요소가 뒤의 요소보다 크면 두 요소를 교환합니다
            if arr[j] > arr[j + 1]:
                arr[j], arr[j + 1] = arr[j + 1], arr[j]
    return arr

def second(arr):
    n = len(arr)
    # 배열의 모든 요소를 순회합니다
    for i in range(n):
        for j in range(i + 1, n):
            for k in range(j + 1, n):
                # 세 개의 요소를 비교해 필요하면 교환합니다
                if arr[i] > arr[j]:
                    arr[i], arr[j] = arr[j], arr[i]
                if arr[i] > arr[k]:
                    arr[i], arr[k] = arr[k], arr[i]
                if arr[i] > arr[j]:
                    arr[i], arr[j] = arr[j], arr[i]
    return arr
```

<p> 
- 정답 : 첫 번째 함수인 `first`의 시간 복잡도는 \( O(n^2) \)입니다. 두 번째 함수인 `second`의 시간 복잡도는 \( O(n^3) \)입니다. 최대 \( n \)번의 연산이 필요한 반복문 3개가 중첩되어 있기 때문입니다. 따라서 `first`의 코드가 더 효율적으로 실행됩니다. </p> 
 </details> 
<details>
<summary>Q2. 시간 복잡도와 빅 오 표기법의 차이를 설명해 보세요.</summary>
<p>
- 정답 : 시간 복잡도는 입력의 크기에 따른 프로그램의 실행 시간 관계를 나타냅니다. 실행 시간은 연산 횟수에 비례하므로 입력의 크기에 따른 프로그램의 연산 횟수로 간주되기도 합니다. 빅 오 표기법은 함수의 접근적 상향을 나타내는데, 시간 복잡도를 표현하기 위해 자주 사용됩니다. 시간 복잡도를 표현할 때 빅 오 표기법이 사용된다면 입력에 따른 실행 시간의 접근적 상향을 의미하는 것입니다.

</p>
</details>

<details>
<summary>Q3. 인코딩된 값과 해시 값의 차이를 설명해 보세요.</summary>
<p>
- 정답 :인코딩은 데이터를 다른 방식으로 표현하기 위해 변환하는 것입니다. 인코딩된 값은 디코딩을 거쳐 다시 변환될 수 있습니다. 예를 들어 base64와 아스키 인코딩은 모두 컴퓨터가 이해하는 코드의 형식으로 변환될 수 있고, 그렇게 변환된 코드는 사람이 이해할 수 있는 데이터의 형태로 다시 디코딩할 수 있습니다.

반면, 해시 값은 해시 함수를 사용하여 고정 길이의 임의의 값으로 데이터를 변환한 결과를 말합니다. 해시 함수는 인코딩과는 달리 단방향 함수이기 때문에 데이터를 다시 변환할 수 없습니다. 또한 해시 함수는 임의의 길이의 데이터를 입력받아 고정된 길이의 해시 값을 출력하고, 입력값이 조금이라도 달라지면 해시 값도 완전히 다른 값으로 변경됩니다.

따라서 인코딩된 값은 주로 데이터를 다양한 형식으로 표현하기 위해 사용하고, 해시 값은 주로 데이터의 무결성을 검증하거나 데이터를 빠르게 검색하기 위해 사용합니다.

</p>
</details>
<details>
<summary>Q4. 스택을 배열로 구현해 보세요(push와 pop 연산은 반드시 구현해야 합니다).</summary>
<p>
- 정답 :인코딩은 데이터를 다른 방식으로 표현하기 위해 변환하는 것입니다. 인코딩된 값은 디코딩을 거쳐 다시 변환될 수 있습니다. 예를 들어 base64와 아스키 인코딩은 모두 컴퓨터가 이해하는 코드의 형식으로 변환될 수 있고, 그렇게 변환된 코드는 사람이 이해할 수 있는 데이터의 형태로 다시 디코딩할 수 있습니다.

반면, 해시 값은 해시 함수를 사용하여 고정 길이의 임의의 값으로 데이터를 변환한 결과를 말합니다. 해시 함수는 인코딩과는 달리 단방향 함수이기 때문에 데이터를 다시 변환할 수 없습니다. 또한 해시 함수는 임의의 길이의 데이터를 입력받아 고정된 길이의 해시 값을 출력하고, 입력값이 조금이라도 달라지면 해시 값도 완전히 다른 값으로 변경됩니다.

따라서 인코딩된 값은 주로 데이터를 다양한 형식으로 표현하기 위해 사용하고, 해시 값은 주로 데이터의 무결성을 검증하거나 데이터를 빠르게 검색하기 위해 사용합니다.

</p>
</details>
<details>
<summary>Q5. 큐를 배열로 구현해 보세요(인큐와 디큐 연산은 반드시 구현해야 합니다).</summary>
<p>
- 정답 :인코딩은 데이터를 다른 방식으로 표현하기 위해 변환하는 것입니다. 인코딩된 값은 디코딩을 거쳐 다시 변환될 수 있습니다. 예를 들어 base64와 아스키 인코딩은 모두 컴퓨터가 이해하는 코드의 형식으로 변환될 수 있고, 그렇게 변환된 코드는 사람이 이해할 수 있는 데이터의 형태로 다시 디코딩할 수 있습니다.

반면, 해시 값은 해시 함수를 사용하여 고정 길이의 임의의 값으로 데이터를 변환한 결과를 말합니다. 해시 함수는 인코딩과는 달리 단방향 함수이기 때문에 데이터를 다시 변환할 수 없습니다. 또한 해시 함수는 임의의 길이의 데이터를 입력받아 고정된 길이의 해시 값을 출력하고, 입력값이 조금이라도 달라지면 해시 값도 완전히 다른 값으로 변경됩니다.

따라서 인코딩된 값은 주로 데이터를 다양한 형식으로 표현하기 위해 사용하고, 해시 값은 주로 데이터의 무결성을 검증하거나 데이터를 빠르게 검색하기 위해 사용합니다.

</p>
</details>

<details>
<summary>Q5. 큐를 배열로 구현해 보세요(인큐와 디큐 연산은 반드시 구현해야 합니다).</summary>
<p>
- 정답 :
</p>

```python
class myQueue:
    def __init__(self):
        self.items = []

    def enqueue(self, item):
        self.items.append(item)

    def dequeue(self):
        if self.is_empty():
            return None
        item = self.items[0]
        del self.items[0]
        return item

    def is_empty(self):
        return len(self.items) == 0

q = myQueue()
q.enqueue('a')
q.enqueue('b')
q.enqueue('c')

print(q.dequeue())  # a
print(q.dequeue())  # b
print(q.dequeue())  # c
```

</details>
