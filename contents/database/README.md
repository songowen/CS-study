# Operating System (운영체제)

## 기본 자료 구조 [▶︎ 🗒](basic.md)

- [프로세스와 스레드](./basic.md#프로세스와-스레드)
- [동기화와 교착 상태](./basic.md#동기화와-교착-상태)
- [CPU 스케줄링](./basic.md#CPU-스케줄링)
- [가상 메모리](./basic.md#가상-메모리)
- [파일 시스템](./basic.md#파일-시스템)

---

## 질의응답

<details>
<summary>운영체제의 커널이 무엇이며, 커널이 왜 존재하는지에 대해 설명해 보세요. (134p, 141p)</summary>
<p>
- 정답 : 커널은 운영체제의 핵심 부분으로, 컴퓨터 하드웨어와 응용 프로그램 간의 중재자 역할을 합니다. 커널은 프로세스와 스레드가 올바르게 실행되도록 돕고, 이들이 CPU, 메모리, 보조기억장치 등의 하드웨어를 공정하게 할당받아 실행되도록 합니다. 또 커널은 이중 모드를 운영해 사용자 응용 프로그램이 안전하고 효율적으로 시스템 자원을 사용할 수 있도록 합니다.

- 신우 : 메모리에서 운영체제가 상주해있는 부분을 커널이라고 하며, 사용자가 실행하는 응용 프로그램을 대신하여 컴퓨터의 자원 관리 및 할당, 프로세스 및 스레드를 관리하기 위해 존재합니다.
</p>
</details>

<details>
<summary>메모리 누수는 무엇이며, 어떻게 해결할 수 있는지 설명해 보세요. (145p)</summary>
<p>
- 정답 : 메모리 누수는 프로그램이 할당받은 메모리를 해제하지 않아 메모리가 지속적으로 점유되는 현상을 말합니다. 메모리 누수 문제를 해결하기 위해서는 메모리를 사용한 후 명시적으로 해제하거나 프로그래밍 언어의 가비지 컬렉션을 활용해 정리해야 합니다.

- 신우 : 프로그램이 필요하지 않은 메모리를 계속 점유하는 현상으로, 메모리의 힙 영역에서 메모리 공간을 반환하지 않을 경우 발생합니다. 이는 사용되지 않는 힙 메모리를 해제하는 가비지 컬렉션으로 정리할 수 있습니다.
</p>
</details>

<details>
<summary>지나치게 문맥 교환이 반복되면 어떤 문제가 발생할 수 있나요? (150p)</summary>
<p>
- 정답 : 빈번한 문맥 교환은 실제 작업보다 문맥 저장과 복구에 CPU 시간을 사용하게 되므로 효율성을 떨어뜨립니다. 또한 캐시 메모리의 데이터를 반복적으로 무효화하게 되므로 캐시미스율이 증가하고, 캐시 미스와 문맥 교환 오버헤드로 인한 전체 시스템의 처리 속도가 저하될 수 있습니다.

- 신우 : 지나치게 문맥 교환이 반복될 경우 캐시미스가 발생할 확률이 늘어나 비효율적이게 됩니다.
</p>
</details>

<details>
<summary>블로킹 입출력과 논블로킹 입출력의 차이점에 대해 설명해 보세요. (152p)</summary>
<p>
- 정답 : 블로킹 입출력과 논블로킹 입출력의 차이는 프로세스가 입출력 작업을 수행할 때 대기하는지 여부에 있습니다. 블로킹 입출력에서 프로세스가 입출력 작업을 시작하면 해당 작업이 완료될 때까지 대기하는 반면, 논블로킹 입출력에서는 프로세스가 입출력 작업을 시작한 후, 작업이 완료되기를 기다리지 않고 곧바로 다음 명령을 수행합니다.

- 신우 : 블로킹 입출력의 경우 시스템 콜이 발생하면 시스템 콜의 입출력 작업이 완료되기 전 까지 대기하게 되지만, 논 블로킹 입출력의 경우는 시스템 콜이 발생할 경우 해당 시스템 콜이 정상적으로 송신이 된 것을 확인한 직후 해당 입출력 작업의 실행 결과를 기다리지 않고 다음 명령을 수행합니다.
</p>
</details>

<details>
<summary>동일한 코드를 여러 프로세스로 동시에 실행하는 것과 여러 스레드로 프로세스를 실행하는 것에는 어떤 차이가 있나요? (156p) </summary>
<p>
- 정답 : 차이점은 자원 공유 여부에 있습니다. 동일한 코드를 여러 프로세스에서 동시에 실행하는 경우, 기본적으로 각 프로세스는 독립적으로 실행되며 메모리, 파일 등의 자원을 공유하지 않습니다. 반면, 여러 스레드로 프로세스를 실행하는 경우, 동일한 프로세스 내에서 실행되며 자원을 공유합니다. 따라서 스레드 간에는 통신과 협력이 쉽지만, 한 스레드의 문제가 전체 프로세스에 영향을 줄 수 있습니다. 반면, 프로세스는 스레드와 달리 서로 독립적이기 때문에 한 프로세스의 문제가 다른 프로세스에 미치는 영향이 적습니다.

- 신우 : 여러 프로세스를 동시에 실행하는 것은 멀티프로세스로, 서로의 자원을 공유하지 않는 방면, 여러 스레드로 프로세스를 실행하는 경우에는 서로 자원을 공유한다는 차이점이 있습니다.
</p>
</details>

<details>
<summary>스레드를 생성하고 실행할 때 사용하는 join에 대해 설명해 보세요. (158p)</summary>
<p>
- 정답 : join은 생성된 스레드의 실행이 완료될 때까지 기다리게 하는 메서드를 말합니다. 생성된 스레드의 실행이 종료되기도 전에 해당 스레드를 생성한 스레드가 종료되거나 다음 작업을 수행하는 것을 방지할 수 있습니다.

- 신우 : 스레드를 생성한 주체가, 생성/실행된 스레드가 종료될 때까지 대기해야 함을 의미합니다.
</p>
</details>

<details>
<summary>공유메모리 기반 IPC가 소켓 통신보다 빠른 이유를 설명해 보세요. (160p)</summary>
<p>
- 정답 : 공유 메모리는 동일한 메모리 공간에 직접 접근하여 데이터를 주고받고, 마치 자신의 메모리 공간을 읽고 쓰는 것처럼 IPC가 이루어지기 때문에 빠릅니다. 이에 반해 소켓 통신은 주고받는 데이터가 커널을 통하므로 추가적인 오버헤드가 발생할 수 있어, 공유 메모리 기반 IPC보다 다소 느릴 수 있습니다.

- 신우 : 공유 메모리 기반 IPC의 경우 프로세스들이 각자의 메모리 영역을 쓰고 읽는 것 뿐이기 때문에, 커널을 통해 데이터를 송수신하는 소켓 통신보다 빠릅니다.
</p>
</details>

<details>
<summary>소스 코드를 실행했더니 ‘Segmentation fault(core dumped)’라는 메시지와 함께 코드가 작동하지 않습니다. 어떻게 해야 할까요? (163p)</summary>
<p>
- 정답 : 생성된 코어 덤프 파일에 비정상 종료 당시의 메모리 상태나 비정상 종료 원인을 유추할 정보가 명시되어 있을 것입니다. 이 코어 덤프 파일을 분석하여 문제의 원인을 파악해야 합니다. 가령 코어 덤프 파일에 스택 트레이스가 포함되어 있을 경우, 문제가 발생한 순간 함수 호출 관계로 문제 발생 시점을 진단할 수 있습니다.

- 신우 : 코어 덤프는 프로그램이 비정상적으로 종료되는 경우 생성되는 파일입니다. 특정 시점에서 작업하던 메모리 상태가 기록되어 있으므로, 해당 파일을 가지고 디버깅을 하면 문제의 원인을 찾을 수 있습니다.
</p>
</details>


<details>
<summary>다음 코드에는 문제가 있습니다. 어떤 문제가 있는지 설명해보세요. (167p)</summary>

```C++
#include <stdio.h>
#include <pthread.h>

int shared_data = 0;	// 공유 데이터

void* increment(void* arg) {
	int i;
	for (i = 0; i < 100000; i++){
		shared_data++;	// 공유 데이터 증가
	}
	return NULL;
}

void* decrement(void* arg){
	int i;
	for (i = 0; i < 100000; i++){
		shared_data--;	// 공유 데이터 감소
	}
	return NULL;
}

int main(){
	pthread_t thread1, thread2;

	pthread_create(%thread1, NULL, increment, NULL);
	pthread_create(%thread2, NULL, decrement, NULL);

	pthread_join(thread1, NULL);
	pthread_join(thread2, NULL);

	printf("Final value of shared_data: %d\n", shared_data);

	return 0
}
```

<p>
- 정답 : 공유데이터인 'shared_data'가 두 스레드에서 동시에 수정되는 과정에서 발생할 수 있는 레이스 컨디션 문제가 있습니다. 'shared_data++'와 'shared_data--'라는 임계 구역에서의 연산이 하나씩만 수행되지 않기 때문에 데이터의 일관성이 보장되지 않을 수 있습니다.
</p>
</details>


<details>
<summary>위에서 제시한 코드의 문제를 해결해보세요. (170p)</summary>
<p>
- 정답 : 문제를 해결하려면 mutex 등을 활용해 공유 자원에 대한 접근을 동기화해야 합니다. 다음과 같은 코드를 추가하면 임계구역을 보호할 수 있습니다.</p>

```C++
#include <stdio.h>
#include <pthread.h>

int shared_data = 0;  // 공유 데이터
pthread_mutex_t mutex;  // 뮤텍스 변수 선언

void* increment(void* arg) {
    int i;
    for (i = 0; i < 100000; i++) {
        pthread_mutex_lock(&mutex);  // 뮤텍스 잠금
        shared_data++;  // 공유 데이터 증가
        pthread_mutex_unlock(&mutex);  // 뮤텍스 해제
    }
    return NULL;
}

void* decrement(void* arg) {
    int i;
    for (i = 0; i < 100000; i++) {
        pthread_mutex_lock(&mutex);  // 뮤텍스 잠금
        shared_data--;  // 공유 데이터 감소
        pthread_mutex_unlock(&mutex);  // 뮤텍스 해제
    }
    return NULL;
}

int main() {
    pthread_t thread1, thread2;

    pthread_mutex_init(&mutex, NULL);  // 뮤텍스 초기화

    pthread_create(&thread1, NULL, increment, NULL);
    pthread_create(&thread2, NULL, decrement, NULL);

    pthread_join(thread1, NULL);
    pthread_join(thread2, NULL);

    printf("Final value of shared_data: %d\n", shared_data);

    pthread_mutex_destroy(&mutex);  // 뮤텍스 제거
    return 0;
}
```

</details>

<details>
<summary>스레드 안전하지 않은 메서드를 동기화하지 않으면 어떤 문제가 생길 수 있나요? (186p)</summary>
<p>
- 정답 : 여러 스레드가 동시에 실행될 경우 레이스 컨디션이 발생하여 데이터의 일관성이 깨질 수 있습니다. 따라서, 추가적인 동기화 도구를 사용하거나, 스레드 안전한 메서드를 사용해야 합니다.
</p>
</details>

<details>
<summary>교착상태가 무엇인지, 왜 발생하는지 설명해 보세요. (189p)</summary>
<p>
- 정답 : 교착 상태는 2개 이상의 프로세스가 서로 상대방의 자원을 기다리며 무한정 대기하는 상황을 말합니다. 이는 네가지 조건이 충족될 때 발생할 수 있습니다. 첫째, 자원이 상호 배제되어 한번에 프로세스만 사용할 수 있는 경우, 둘째, 이미 자원을 점유한 프로세스가 다른 자원을 기다리는 경우, 셋째, 자원이 비선점되어 다른 프로세스가 강제로 자원을 빼앗지 못하는 경우, 넷째, 프록세스들이 원형으로 자원을 대기하는 경우입니다. 이러한 조건들이 동시에 충족될 때 교착상태가 발생할 수 있습니다.
</p>
</details>

<details>
<summary>리눅스 운영체제에서 일반적인 사용자 프로세스가 어떻게 CPU를 할당 받아 실행되는지 설명해 보세요. (202p)</summary>
<p>
- 정답 : 리눅스에서 일반적인 사용자 프로세스는 CFS 스케줄러에 의해 스케줄링 됩니다. CFS 스케줄러는 각 프로세스에 CPU의 시간을 공평하게 배분하는 것을 목표로 합니다. 기본적으로 각 프로세스의 가상실행시간인 vruntime을 유지하며, vruntime이 가장 작은 프로세스부터 스케줄링합니다. 프로세스의 vruntime은 실제 실행시간에 프로세스의 우선순위에 따른 가중치를 고려하여 계산되며, 우선순위가 높을 수록 vruntime의 증가가 느려지기 때문에 우선순위가 높은 프로세스는 더 자주 cpu를 할당받게 됩니다.
</p>
</details>

<details>
<summary>디버깅할 때 주로 볼 수 있는 주소는 실제 물리 메모리 주소일까요? (206p)</summary>
<p>
- 정답 : 디버깅할 떄 주로 볼 수 있는 주소는 실제 메모리의 물리 주소가 아니라 논리 주소(가상 메모리 주소)입니다. 프로세스를 실행하는 CPU나 메모리에 적재된 프로세스 입장에서 메모리 내에 물리 주소를 모두 알기는 어렵기 때문에 프로세스마다 부여되는 논리 주소(가상 주소)를 활용합니다. 따라서 디버깅할 때의 메모리 주소는 프로세스의 가상 주소 공간 내에서의 주소에 해당합니다. 이 가상 주소(논리 주소)는 CPU와 메모리 사이에 위치하는 MMU에 의해 물리 주소로 변환됩니다.
</p>
</details>

<details>
<summary>메모리가 부족하면 어떤 현상이 발생할 수 있는지 설명해 보세요. (207p, 221p)</summary>
<p>
- 정답 : 메모리가 부족하면 운영체제는 부족한 메모리를 보완하기 위해 디스크에 메모리 페이지를 저장하고, 필요할 때 다시 불러오는 과정인 스와핑을 사용하게 됩니다. 이 작업이 과도하게 이루어질 경우 스래싱이라는 현상을 초래하며, 시스템이 지속적으로 디스크 I/O에만 몰두하게 되어 실질적인 작업 처리가 거의 이루어지지 않게 됩니다.
</p>
</details>

<details>
<summary>4GB보다 큰 크기의 프로그램을 4GB인 물리 메모리로 실행할 수 있을까요? 실행할 수 있다면 어떻게 가능할까요? (209p)</summary>
<p>
- 정답 : 가상 메모리 기술을 통해 가능합니다. 운영체제는 프로세스가 필요한 메모리 공간을 가상 주소로 할당하고, 실제 물리 메모리에는 필요한 부분만 적재합니다. 필요하지 않은 부분은 디스크의 스왑 영역에 저장하고, 필요할 때 다시 물리 메모리에 적재할 수 있습니다. 이러한 기술을 가상 메모리 기술이라고 하며, 이를 통해 물리 메모리보다 큰 프로세스를 실행할 수 있습니다.
</p>
</details>

<details>
<summary>페이지 폴트를 처리하는 과정을 설명해보세요. (215p)</summary>
<p>
- 정답 : CPU의 페이지 폴트 처리과정은 1. CPU가 기존의 작업내역을 백업하고, 2. 페이지 폴트 처리 루틴을 실행합니다. 페이지 처리 루틴은 메모리로 원하는 페이지를 가져와 유효 비트를 1로 변경해주는 작업을 말합니다. 3. 이렇게 페이지 폴트를 처리하면 CPU가 해당 페이지에 접근할 수 있게 됩니다.
</p>
</details>

<details>
<summary>프로세스의 페이지 테이블이 모두 메모리에 적재될 경우에 발생할 수 있는 문제점과 해결 방안을 설명해 보세요. (217p)</summary>
<p>
- 정답 : 크게 두 가지 문제 상황이 발생할 수 있습니다. 먼저, 메모리 접근 횟수가 많아져 성능이 저하됩니다. 페이지 테이블 접근과 실제 데이터 접근으로 인해 메모리 접근이 두 배로 늘어나기 때문입니다. 
또, 페이지 테이블이 차지하는 메모리 용량이 커져 비효율적입니다. 이는 TLB를 사용해 페이지 테이블의 일부를 캐싱하거나, 계층적 페이징 기법을 사용해 페이지 테이블을 나누어 관리함으로써 메모리 접근 횟수와 메모리 사용량을 줄일 수 있습니다.
</p>
</details>

<details>
<summary>파일 디스크립터는 무엇을 식별하는 정보인가요? (225p)</summary>
<p>
- 정답 : 파일 디스크립터는 운영체제에서 파일을 식별하기 위한 저수준 정보입니다. 리눅스를 비롯한 여러 운영체제에서는 입출력장치, IPC(파이프,소켓) 등도 일종의 파일로 간주해 파일 디스크립터로 식별하고 다룰 수 있습니다. 또한 파일 디스크립터는 파일뿐만 아니라 표준 입력(0), 표준 출력(1), 표준 에러(2)와 같은 입출력 스트림도 식별할 수 있습니다.
</p>
</details>

<details>
<summary>응용 프로그램이 새로운 파일을 만들고, “hello”라는 문자열을 입력한 뒤 저장했습니다. 이 과정에서 컴퓨터 내부(커널)에서는 어떤 일이 발생하는지 설명해 보세요. (225p)</summary>
<p>
- 정답 : 먼저, 응용프로그램이 open() 시스템 콜을 통해 운영체제에 파일을 생성하도록 요청합니다. 이때 CPU가 사용자 모드에서 커널 모드로 전환되어 운영체제가 커널 공간에서 파일 생성코드를 실행하고, 파일 시스템에 접근해 새로운 파일을 생성합니다. 파일이 생성되면 응용 프로그램은 write() 시스템 콜을 사용하여 생성한 파일에 'hello' 문자열을 씁니다. 이 과정에서도 CPU는 커널 모드로 전환되어 실행됩니다. 문자열이 성공적으로 쓰이면 close() 시스템 콜을 호출하여 파일을 닫습니다. 작업이 완료되면 사용자 모드로 전환됩니다.
</p>
</details>

<details>
<summary>공장 초기화된 보조기억장치가 있다고 가정해보세요. 이때 파일 시스템을 만들고, 텍스트 파일을 저장하기까지의 과정을 설명해 보세요. (231p)</summary>
<p>
- 정답 : 파티션을 생성하고 포매팅하여 파일 시스템을 만듭니다. 파일 시스템을 마운트 한 뒤, 파일 탐색기나 터미널을 통해 텍스트 파일을 생성하고 저장하면 됩니다.
</p>
</details>

<details>
<summary>- EXT4 파일 시스템에서 디렉터리 내 파일의 데이터를 찾는 과정을 설명해 보세요. (233p)</summary>
<p>
- 정답 : 파일이 속한 디렉터리에서 파일 이름에 해당하는 디렉터리 엔트리를 찾고, 해당 파일의 아이노드 번호를 얻습니다. 이렇게 얻은 아이노드 번호를 이용하여 아이노드 테이블에서 해당 아이노드를 찾습니다. 아이노드는 파일의 속성과 데이터가 저장된 위치를 포함하고 있으므로 아이노드를 통해 실제 파일 데이터가 저장된 위치에 접근할 수 있습니다.
</p>
</details>

<details>
<summary>아이노드란 무엇이며, 아이노드에는 어떤 정보를 저장하는지 설명해 보세요 (233p)<br>
(부팅 과정을 설명해 보세요)</summary>
<p>
- 정답 : 아이노드는 파일이 저장된 위치와 속성을 비롯해, 사실상(파일의 이름을 제외한) 파일의 모든 것이 담겨있는 색인 블록입니다.
</p>
</details>

<details>
<summary>운영체제가  메모리에 적재되기 까지의 과정을 설명해 보세요. (239p)<br>
(부팅 과정을 설명해 보세요)</summary>
<p>
- 정답 : 컴퓨터 전원이 켜지면 CPU는 ROM에 저장된 BIOS를 실행합니다. BIOS는 하드웨어를 검사하는 POST 수행 후, 하드디스크의 MBR을 읽어 부트 로더를 로드합니다. 부트 로더가 커널의 위치를 찾아 RAM에 적재함으로써 커널이 메모리에 로드됩니다.
</p>
</details>

<details>
<summary>가상 머신과 컨테이너의 차이점에 대해 설명해 보세요. (241p)</summary>
<p>
- 정답 : 가상머신은 하이퍼바이저를 통해 물리 하드웨어 위에서 여러 운영체제를 독립저긍로 실행합니다. 각 가상 머신은 전체 운영체제와 가상 하드웨어를 포함하기 때문에 상대적으로 무겁습니다. 반면 컨테이너는 기본적으로 커널을 공유하고 실행하고자 하는 특정 애플리케이션만을 위한 격리성을 제공하기 때문에 상대적으로 가볍고 빠릅니다.
</p>
</details>

<details>
<summary>페이지 교체 알고리즘을 설명해주세요. 그리고 대표적인 페이지 교체 알고리즘을 설명해주세요. (223p)</summary>
<p>
- 정답 : 페이지 교체 알고리즘은 메모리에 적재된 페이지 일부를 스왑 아웃 할 때 보조기억장치로 내보낼 페이지를 선택하는 방법입니다. 페이지 교체 알고리즘의 목적은 페이지폴트 발생 빈도를 줄이는 것입니다.
- 대표적인 페이지 교체 알고리즘은 FIFO 페이지 교체 알고리즘, 최적 페이지 교체 알고리즘, LRU페이지 교체 알고리즘이 있습니다.
FIFO 교체 알고리즘은 메모리에 가장 먼저 적재된 페이지부터 스왑 아웃 하는 페이지 교체 알고리즘입니다. 구현은 간단하지만 초기부터 사용하던 페이지를 스왑 아웃 할 우려가 있습니다.
최적 페이지 알고리즘은 앞으로 사용 빈도가 가장 낮은 페이지를 교체하는 알고리즘입니다. 앞으로 가장 적게 사용할 페이지를 스왑 아웃 하여 가장 낮은 페이지 폴트율을 보장하는 알고리즘이지만, 앞으로 가장 적게 사용할 페이지를 미리 예측하기 어렵기 때문에 실제 구현이 어려운 알고리즘입니다.
LRU 페이지 교체 알고리즘은 가장 적게 사용한 페이지를 교체하는 페이지 알고리즘입니다. 보편적으로 사용되는 페이지 교체 알고리즘의 원형이며 이를 기반으로 만들어진 다양한 파생 알고리즘이 있습니다.
</p>
</details>

<details>
<summary>CPU 스케줄링 알고리즘의 종류에 대해 아는 대로 설명하시오 (199p)</summary>

- 정답 : 전통적인 CPU 스케줄링 알고리즘의 종류로는 총 7가지가 있습니다.   
1. 선입 선처리 스케줄링 : 단순히 준비 큐에 삽임된 순서대로 먼저 CPU를 요청한 프로세스부터 CPU를 할당하는 스케줄링 방식으로 먼저 삽입된 프로세스의 오랜 실행 시간으로 나중에 삽입된 프로세스의 실행이 지연되는 "호위 효과" 문제가 발생할 수 있습니다.   
2. 최단 작업 우선 스케줄링(SJF) : cpu를 이용하는 길이가 가장 짧은 프로세스부터 실행하는 스케줄링 방식, 기본적으로 비선점형으로 분류되나, 선점형으로 구현될 수도 있다.
3. 라운드 로빈 스케줄링(RR) : 선입 선처리 스케줄링에 타임 슬라이스라는 개념이 더해진 스케줄링 방식, 프로세스가 지정된 타임 슬라이스만큼 실행되면 완료되지 않았더라도 중도에 큐 맨 뒤로 삽입됨.
4. 최소 잔여 시간 스케줄링(SRT) : 프로세스가 정해진 타임 슬라이스만큼 CPU를 이용하되, 남아 있는 작업시간이 가장 적은 프로세스를 다음으로 CPU를 이용할 프로세스로 선택.
5. 우선순위 스케줄링 : 프로세스에 우선순위를 부여해 가장 높은 우선순위를 가진 프로세스부터 실행하는 스케줄링 방식, 우선순위가 낮은 프로세스가 계속해서 실행이 연기되는 "아사"현상이 발생할 수 있으며 이를 방지하기 위한 기법으로는 오래 대기한 프로세스의 우선순위를 높이는 "에이징"이 있다.
6. 다단계 큐 스케줄링 : 우선순위 스케줄링의 발전된 형태로 우선순위별로 여러 개의 준비 큐를 사용하는 방식, 프로세스들이 큐 사이를 이동할 수 없기 때문에 이 방식 또한 "아사" 현상이 발생할 수 있다.
7. 다단계 피드백 큐 스케줄링 : 다단계 큐 스케줄링과 유사하지만 프로세스들이 큐 사이를 이동할 수 있다는 차이점이 있다, 다단계 피드백 큐 스케줄링에 새롭게 진입하는 프로세스는 먼저 가장 높은 우선순위 큐에 삽입되고 타임 슬라이스	동안 실행된다. 해당 큐에서 실행이 완료되지 않은 프로세스는 다음 우선순위 큐에 삽입된다, 결국 오래 CPU를 사용해야 하는 프로세스의 우선순위가 점차 낮아지게 되는 방식이다.

</details>

<details>
<summary>뮤텍스(Mutex)와 세마포어(Semaphore)의 차이에 대해 설명해주세요.</summary>

- 정답 : 
공유된 자원에 여러개의 프로세스가 동시에 접근하게 되면 임계 영역(Critical Section) 문제가 발생할 수 있고, 이를 해결 하기 위해 데이터를 한번에 하나의 프로세스만 접근할 수 있도록 제한을 두는 동기화 방식을 취해야합니다.

동기화 도구에는 대표적으로 뮤텍스와 세마포어가 있습니다. 가장 큰 차이점은 동기화 대상의 개수입니다.

Mutex는 동기화 대상이 오직 1개 일 때 사용하고, Semaphore는 동기화 대상이 1개 이상일 때 사용합니다.

세마포어는 뮤텍스가 될수 있지만, 뮤텍스는 세마포어가 될 수 없습니다. 뮤텍스는 0과 1로 이루어진 이진상태를 가지므로 Binary Semaphore라고도 합니다.

뮤텍스는 자원 소유 가능 + 책임을 가지는 반면, 세마포어는 자원 소유가 불가합니다. 뮤텍스는 상태가 0, 1 뿐이므로 Lock을 가질 수 있습니다.

현재 수행중인 프로세스가 아닌 다른 프로세스가 세마포어를 해제할 수 있지만, 뮤텍스는 lock을 획득한 프로세스가 반드시 그 락을 해제해야 합니다.

</details>


